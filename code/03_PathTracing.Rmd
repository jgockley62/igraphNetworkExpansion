---
title: "03_PathTracing"
output: html_document
---

```{r setup, include=FALSE}
is.installed <- function(mypkg){
    is.element(mypkg, installed.packages()[,1])
  } 

if( !is.installed("paxtoolsr") ){
  BiocManager::install("paxtoolsr")
}
if( !is.installed("clusterProfiler") ){
  BiocManager::install("clusterProfiler")
}

knitr::opts_chunk$set(echo = TRUE)
setwd('~/igraph_Network_Expansion/')
library(igraph)
library(paxtoolsr)
library(RJSONIO)
library(httr)
library(DOSE)
library(org.Hs.eg.db)
library(clusterProfiler)
library(parallel)
library(doParallel)
library(RColorBrewer)
devtools::install_github("jhrcook/HotNetvieweR")
library(HotNetvieweR)
source('~/igraph_Network_Expansion/igraphhack/igraphplot2.R')
```

## R Import Data

```{r Import}
setwd('~/igraph_Network_Expansion/')

reticulate::use_python("/usr/bin/python", required = TRUE)
synapseclient <- reticulate::import("synapseclient")
syn_temp <- synapseclient$Synapse()
syn_temp$login(  )

#Use Co-expression to filter
Use_Cor <- 'NO'
#use directed network
Directed <- 'YES'
#Filter out low edge occurences
Filter_Edges <- 'YES'
#Simple edges ( One Edge per-interaction )
Simple <- 'YES'

if( Use_Cor == 'YES' ){
  if( Directed == 'YES' ){
    load( syn_temp$get('syn23283482')$path )
    load( syn_temp$get('syn23283475')$path )
    #Dummy a network (Could choose JS or Non-JS here)
    net <- net_directed

  }else{
    #Pull Networks:
    load( syn_temp$get('syn22863899')$path )
    load( syn_temp$get('syn22863896')$path )
    #Dummy a network (Could choose JS or Non-JS here)
    net <- net_undirected

  }
}else{
  if( Directed == 'YES' ){
    load( syn_temp$get('syn23283482')$path )
    load( syn_temp$get('syn23283475')$path )
    #Dummy a network (Could choose JS or Non-JS here)
    net <- net_directed

  }else{
    #Pull Networks:
    load( syn_temp$get('syn22992753')$path )
    load( syn_temp$get('syn22992709')$path )
    #Dummy a network (Could choose JS or Non-JS here)
    net <- net_undirected

  }
}

if( Simple == 'YES' ){
  
}

if( Filter_Edges == 'YES' ){
  #Net is: 13,867 Vertacies and 806,950 Edges
  # A)
  # loose( 246 vertices ) -- A == 13621 Vertacies and 544871 Edges
  test_net <- igraph::subgraph.edges( net,
                              E(net)[ ( E(net)$EdgeRep == 1  & 
                                        E(net)$Occurance == 1 & 
                                        E(net)$Avg_Cortex_CE == 0 ) == F ],
                              delete.vertices = TRUE
                            )
  # loose( 3053 vertices ) -- C 10,814 Vertacies and 179,148 Edges
  test_net <-  igraph::subgraph.edges( test_net,
                              E(test_net)[ ( E(test_net)$EdgeRep == 1  &
                                             E(test_net)$Occurance == 2 &
                                             E(test_net)$Avg_Cortex_CE == 0  ) == F ],
                              delete.vertices = TRUE
                            )
  #loose ( 424 vertacies )
  #B 13,443 vertices and 441,227 Edges
  #test_net <- subgraph.edges( net,
  #                            E(net)[ ( E(net)$EdgeRep == 1  &
  #                                      E(net)$Occurance == 2 & 
  #                                      E(net)$Avg_Cortex_CE == 0  ) == F ],
  #                            delete.vertices = TRUE
  #                          )
  
  # E)
  # loose( 3691 vertices ) -- A == 10176 Vertacies and 151912 Edges
  test_net <-  igraph::subgraph.edges( net,
                              E(net)[ ( E(net)$EdgeRep == 1  & 
                                        E(net)$Avg_Cortex_CE == 0 ) == F ],
                              delete.vertices = TRUE
                            )
  
  net <- test_net
 

}


#Annotate vertices on Omics Weights:
#_Old Omics Only#  OMICS <- read.csv(syn_temp$get('syn22758171')$path)
OMICS_dep <- read.csv(syn_temp$get('syn22758171')$path)
#SELECT * FROM syn23019621 WHERE GeneName in ('DDAH2', 'NAPG') 
#syn23019621
OMICS <- read.csv( syn_temp$tableQuery( paste0( 'SELECT * FROM syn24168007 WHERE GeneName in (\'',
                                              paste( names(V(net)), collapse = '\',\'' ),
                                              '\')'),
                                      resultsAs = 'csv' )$filepath)
OMICS <-  OMICS[ , c('ENSG', 'GeneName', 'OmicsScore', 'GeneticsScore', 'Overall')]
colnames(OMICS)[ colnames(OMICS) == 'GeneName' ] <- 'GName'
  
OMICS$GName <- as.character( OMICS$GName )
OMICS$ENSG <- as.character(OMICS$ENSG)
OMICS_dep$GName <- as.character( OMICS_dep$GName )
OMICS_dep$ENSG <- as.character(OMICS_dep$ENSG)

OMICS_alt <- OMICS[ (OMICS$GName %in% "") == F, ]
OMICS_dep <- OMICS_dep[ (OMICS_dep$GName %in% "") == F, ]

#Pull out pseduo genes and NAs,  also ENSG00000281123 is a diff ENSG for RNA and Protein...:
OMICS_alt <- OMICS_alt[ (OMICS_alt$ENSG %in% c(
  'ENSG00000272655',
  'ENSG00000284770',
  'ENSG00000168255',
  'ENSG00000281123'
)) == F,]
OMICS_dep <- OMICS_dep[ (OMICS_dep$ENSG %in% c(
  'ENSG00000272655',
  'ENSG00000284770',
  'ENSG00000168255',
  'ENSG00000281123'
)) == F,]

OMICS_alt <- OMICS_alt[ is.na(OMICS_alt$GName)==F,]
OMICS_alt <- OMICS_alt[ OMICS_alt$ENSG %in% as.character(OMICS_dep$ENSG), ] 

OMICS_alt  <- OMICS_alt[ !duplicated(OMICS_alt$ENSG), ]
row.names( OMICS_alt ) <- OMICS_alt$GName

OMICS_dep <- OMICS_dep[ is.na(OMICS_dep$GName) == F, ]
row.names( OMICS_dep ) <- OMICS_dep$GName

OMICS_alt$RNA_TE <- OMICS_dep[ row.names(OMICS_alt), ]$RNA_TE
OMICS_alt$Pro_TE <- OMICS_dep[ row.names(OMICS_alt), ]$Pro_TE

#vertex_attr(net, "weight", index = V(net)) <- OMICS_alt[ names( V(net)), ]$Final_Weight 
OMICS_alt[ names( V(net)), ]$Overall[ is.na(OMICS_alt[ names( V(net)), ]$Overall) ] <- 0
vertex_attr(net, "weight", index = V(net)) <- OMICS_alt[ names( V(net)), ]$Overall
vertex_attr(net, "RNA_EffectScore", index = V(net)) <- OMICS_alt[ names( V(net)), ]$RNA_TE 
vertex_attr(net, "Pro_EffectScore", index = V(net)) <- OMICS_alt[ names( V(net)), ]$Pro_TE 


# Zero out the TEs
OMICS_alt$PRO_TE_Cor <- OMICS_alt$Pro_TE
OMICS_alt$RNA_TE_Cor <- OMICS_alt$RNA_TE

#OMICS_alt[ OMICS_alt$OmicsScore == 0, ]$PRO_TE_Cor <- 0
#OMICS_alt[ OMICS_alt$OmicsScore == 0, ]$RNA_TE_Cor <- 0

#This was buggin out a bit.... 
  #OMICS_alt[ OMICS_alt$Overall == 0, ]$PRO_TE_Cor <- 0
  #OMICS_alt[ OMICS_alt$Overall == 0, ]$RNA_TE_Cor <- 0
# Depricate for now

vertex_attr(net, "RNA_Cor_EffectScore", index = V(net)) <- OMICS_alt[ names( V(net)), ]$RNA_TE_Cor
vertex_attr(net, "Pro_Cor_EffectScore", index = V(net)) <- OMICS_alt[ names( V(net)), ]$PRO_TE_Cor 
```

```{r functions }
#'Loads gene list
#'
#' Loads a gene list. If is_syn is TRUE file_path is interperated as a synapse
#' ID. Otherwise file_path is interperated as a file path. 
#'
#' file_path is a gene list of gene names in HNGC Symbol format with one gene
#' name per line
#'
#'@param file_path the igraph network to push to synapse eg. net
#'@param network igraph network object to use to filter the vertices From
#'@param is_syn is the list a synapse ID default=FALSE
list_load <- function (file_path, network, is_syn = FALSE) {
  #'@FilePath the path of the file to be loaded eg. '~/igraph_Network_Expansion/InputList/AD_Sentinel_List.txt'
  #'@Net igraph network object to use to filter the vertices From
  
  if (isTRUE(is_syn)) {
    genes <- read.table(
      file=syn_temp$get(file_path)$path, header=F, sep='\n', stringsAsFactors = F
    )[,1]
  }else{
    genes <- read.table(
      file=file_path,header=F, sep='\n', stringsAsFactors = F
    )[,1]
  }
  #Genes in network
  total <- length(genes)
  perc <- length(genes[ genes %in% names(V(network)) ]) / length(genes)
  numb <- length(genes[ genes %in% names(V(network)) ])

  genes <- genes[ genes %in% names( V(network) ) ]

  writeLines(paste0( numb, 
                   ' of ', 
                   total, 
                   ' (', signif(perc, digits = 4)*100,
                   '%) genes from the list appear in the primary network' )
           )
  return( genes )
}

#' @param char is a list entry from get.all.shortest.paths()
name_pull <- function( char ){
  return( names( char ) )
}

#' Calculate the OMICS Scores across paths
#' @param indv_path an indv path
#' @param weights the omics scores as a gene-named vector
path_calc <-  function (indv_path, weights) {
  scores <- weights[names(indv_path)]
  #Trim off the search genes....
  scores <- scores[1:(length(scores) -1)][-1]
  scores <- mean(scores[ !(is.na(scores)) & scores > 0 ])
  return(scores)
}

#'@param weights named vector of genes weights
#'@param indv_path the path of genes
#'@param lim the value to out the path
path_filter <-  function (indv_path, weights, lim ) {
  scores <- weights[names(indv_path)]
  
  #Filter out origin and terminus
  scores <- scores[1:(length(scores) -1)][-1]
  if(length(scores) == 0){
    return(
      list( Keep = names(indv_path),
            Genes = names(indv_path),
            Used = 1,
            Passed = 1
          )
    )
  }
  scores <- scores[ !(is.na(scores)) ]
  if(length(scores) > 0){
    used <- 1
  }else{ used <- 0 }
  if (mean(scores) > lim){
    return(
      list( Keep = names(scores),
            Genes = names(scores),
            Used = used,
            Passed = 1
          )
    )
  }else{
    return(
      list( Keep = NA,
            Genes = names(scores),
            Used = used,
            Passed = 0
      )
    )
  }
}

#' Finds the limit cutoff when target and sentinal paths are given
#'
#' @param vertices the vertices vector from find_limit
#' @param path_obj pathtrace object from short_paths()
#' @param lim the filter limit value
#' @param path_name the name of the path for message (target or sentinal)
#' @param weights the gene OMICS scores or score metric by verex to weight paths
path_obj_filter <- function( path_obj, vertices, lim, path_name, weights ) {
  ## Target path filtering
  ## Target path filtering
  if ((length(vertices) == 1) & 
      is.na(vertices)[1]) {
         message('Target Path Trace Returned No Paths')
  }else{
    # Filter the target Paths
    fitlered_paths <- parallel::mclapply( 
      path_obj$res,  
      path_filter, 
      lim=lim, 
      weights=weights,
      mc.cores = 14
    ) 
      
    filter_summary <- do.call(Map, c(c, fitlered_paths))
    
    vertices <- filter_summary$Keep[ !duplicated(filter_summary$Keep)]
    vertices <- vertices[!(is.na(vertices))]
    
    all_vertices <- filter_summary$Genes[ !duplicated(filter_summary$Genes)]
    all_vertices <- all_vertices[!(is.na(all_vertices))]
       
    #Paths Kept - ISSUE Here
    message(paste0(
      sum(filter_summary$Passed),
      " ",
      path_name,
      " paths out of ",
      length(path_obj$res), 
      " ( ",
      signif(
        sum(filter_summary$Passed) / length(path_obj$res),
        4
      ) * 100,
      "% ) kept"
    ))
      
    #Genes Filtered Out
    message(paste0(
      length(all_vertices) - length(vertices),
      ' of ',
      length(all_vertices),
      ' ', 
      path_name,
      ' genes ( ', 
      signif(
        (length(all_vertices) - length(vertices)) / length(all_vertices), 
        4
        ) * 100,
      '% ) filtered out'
    ))
  }

  return( vertices )
}

#' Finds the limit cutoff when target and sentinal paths are given
#'
#' @param s_path the sentinel path object
#' @param t_path the target path object
#' @param weights OMICS/vertex scores as named vector
find_limit <- function ( s_path, t_path, weights) {
  #if there are no sentinel paths return empty and look at target
  if(length(s_path$res)==0) {
    s_path$res <- 1
  }
  if(length(t_path$res)==0) {
    t_path$res <- 1
  }
  if ((length(s_path$res) == 1) & (length(s_path$res[[1]]) == 1)) {
    sent_keep_vertices <- NA
    
    if ((length(t_path$res) == 1) & (length(t_path$res[[1]]) == 1)) {
      target_vertices <- NA
      limit <- NA
    }else{
      target_vertices <- c(0,0,0)
      #set limit based on targets
      scores <- do.call(c, parallel::mclapply( 
        t_path$res,  
        path_calc, 
        weights=weights,
        mc.cores = 14
      ))
    
      # Look at limit of highest between mean or median non-zero sentinel paths
      target_summary <- summary(
        scores[(scores > 0) & (is.na(scores) == F)]
      )
      if (target_summary['Mean'] > target_summary['Median']) {
        limit <- target_summary['Mean']
      }else{
        limit <- target_summary['Median']
      }
    }
  }else{
    target_vertices <- c(0,0,0)
    sent_keep_vertices <- c(0,0,0)
    sent_scores <- do.call(c, parallel::mclapply( 
      s_path$res,  
      path_calc, 
      weights=weights,
      mc.cores = 14
    ))
  
    # Look at limit of highest between mean or median non-zero sentinal paths
    sentinal_summary <- summary(
      sent_scores[(sent_scores > 0) & (is.na(sent_scores) == F)]
    )
    if (sentinal_summary['Mean'] > sentinal_summary['Median']) {
      limit <- sentinal_summary['Mean']
    }else{
      limit <- sentinal_summary['Median']
    }
  }
  return(list(
    cutoff = limit,
    t_verts = target_vertices,
    s_verts = sent_keep_vertices
  ))
}  

#' Traces the shortest paths of the target gene pairwise to the sentinels
#' Traces the the shortest paths of target gene paiwise to the target gene list
#' Returns the list of genes in paths which score over the median of non-zero
#' paths
#'@param tnet igraph network (Main entire network) eg. net/net_undirected/JS_net_undirected
#'@param target the from gene target eg Genes[1]
#'@param targets List of the total list of targets in the User set eg. Genes
#'@param sentinals List of the sentinal genes to trace to eg. Sentinal
short_paths <- function( tnet, target, targets, sentinals ){
  
  message( paste0( 'Working on: ', target))
  # Pull paths that have median OMICS Score. ( Need to integrate a Genetics+Genomics Measure )
  omics_scores <- setNames(V(tnet)$weight, V(tnet)$name)
  
  # All Shortest paths from target to Target Genes directed
  snet <- igraph::simplify(
    tnet,
    remove.multiple = TRUE,
    remove.loops = FALSE,
  )
  paths <- get.all.shortest.paths(
    snet,
    from = target,
    to = V(snet)[ names(V(snet)) %in% targets ],
    mode = c("all")
  ) 
  
  # All Shortest paths from target to Sentinel Genes
  sent_paths <- get.all.shortest.paths(
    snet,
    from = target,
    to = V(snet)[ names(V(snet)) %in% sentinals ],
    mode = c("all")
  )
  
  ## Find the limit cut off
  cutoff_obj <- find_limit(
    s_path = sent_paths,
    t_path = paths,
    weights = omics_scores
  )
  
  ## Target path filtering
  t_vertices <- path_obj_filter(
    path_obj = paths,
    vertices = cutoff_obj$t_verts,
    lim = cutoff_obj$cutoff,
    path_name ='target',
    weights = omics_scores
  )
  
  ## Sentinal path filtering
  s_vertices <- path_obj_filter(
    path_obj = sent_paths,
    vertices = cutoff_obj$s_verts,
    lim = cutoff_obj$cutoff,
    path_name ='sentinel',
    weights = omics_scores
  )
  
  return(list( Inter = t_vertices, Sentinal=s_vertices))
}

#'Process a path trace list
#'
#'This function takes a path trac object and transforms it into the list of 
#' genes to keep for the sub network
#'@param path_obj pathtrace object from short_paths()
trace_filter <- function (path_obj) {
  
  #collapse Pairwise Pass genes and Sentinal Path Genes
  list_tar <- NULL
  sentinal_tar <- NULL
  len_lts <- NULL
  len_sts <- NULL
  for( i in 1:length(path_obj) ){
    len_lts <- c( len_lts, length( path_obj[[i]]$Inter ) )
    len_sts <- c( len_sts, length( path_obj[[i]]$Sentinal ) )
    list_tar <- c(list_tar, path_obj[[i]]$Inter)
    sentinal_tar <- c(sentinal_tar, path_obj[[i]]$Sentinal)
  
  }
  
  length( list_tar[!duplicated(list_tar)] )
  length( sentinal_tar[!duplicated(sentinal_tar)] )
  
  table( list_tar[!duplicated(list_tar)] %in% sentinal_tar[!duplicated(sentinal_tar)] )
  
  gene_list <- sentinal_tar[!duplicated(sentinal_tar)][ 
    sentinal_tar[ !duplicated(sentinal_tar) ] %in% 
      list_tar[ !duplicated(list_tar) ]
    ]
  return(gene_list)
}

#'Push Network to Synapse
#'
#'This function takes a network object and pushes it to synapse
#'@param network the igraph network to push to synapse eg. net
#'@param net_filename the file name of the network without file extension
#'@param net_synname the desplay name of the network in synapse
#'@param p_id the parent synapse ID of the network destination
#'@param folder the name of the storage folder in the parent synapse ID to store the net
#'@param act_name the name of the syn activity object to 
#'@param act_desc the description of the syn activity object to 
#'@param code the path of the code which generated the network for the provenance (optional)
#'@param repo the repo which generated the network for the provenance (optional)
#'@param syn_used character vector of synIDs to seed the provenance (optional)
#'@param subset An vector of vertex names to filter the network for (optional) eg. test
#'@param prov_object A pre made github code provenance object or vector of objects
store_net <- function (network, net_filename, net_synname,
                       p_id, folder, act_name, act_desc,
                       code=NULL, repo=NULL,
                       syn_used=NULL, subset=NULL,
                       prov_object = NULL) {
  #Set Activity
  activity <- syn_temp$store(synapseclient$Folder(name = folder, parentId = p_id))
  
  #Set annotations
  all.annotations = list(
    dataType = 'Network',
    summaryLevel = 'gene',
    assay	 = 'RNAseq',
    tissueTypeAbrv	= c('IFG', 'STG', 'FP', 'PHG', 'TCX', 'DLFPC'), 
    study = c( 'MSBB', 'ROSMAP', 'Mayo' ), 
    organism = 'HomoSapiens',
    consortium	= 'TreatAD',
    genomeAssemblyID = 'GRCh38'
  )
  
  #Subset the network if there is a vertex vector given 
  if (!is.null(subset)) {
    network <- induced_subgraph( network, v=V(network)[ names(V(network)) %in% subset ] )
  }
  #eg. IGRAPH ff4b668 DN-- 486 6119 -- 
  sub_net_simple <- igraph::simplify(
    network,
    remove.multiple = TRUE,
    remove.loops = FALSE,
    edge.attr.comb = list( interaction = "concat", 
                           Occurance = "concat",
                           UniqCol = "concat",
                           pathway = "concat", 
                           EdgeRep = "mean",
                           Edge = "random",
                           SumOccurence = "mean",
                           DLPFC_CE = "mean",
                           CBE_CE = "mean",
                           FP_CE = "mean",
                           IFG_CE = "mean",
                           PHG_CE = "mean",
                           STG_CE = "mean",
                           TCX_CE = "mean",
                           Avg_Cortex_CE = "mean",
                           Avg_All_CE = "mean"
                        )
  )

  # Github link - "jgockley62/igraph_Network_Expansion" 
  if (is.null(prov_object)) {
    if (!is.null(repo) | !is.null(code)) {
      this_repo <- githubr::getRepo(repository = repo, ref="branch", refName='master')
      this_file <- githubr::getPermlink(repository = this_repo, repositoryPath = code)
    }else{
      this_file <- NULL
    }
  }else{
    this_file <- prov_object
  }
  
  # write file
  igraph::write_graph(
    network,
    paste0( '~/igraph_Network_Expansion/', net_filename,'.graphml'),
    format = "graphml"
  )
  # push file
  enrich_obj <-  syn_temp$store(
    synapseclient$File(
      path=paste0( '~/igraph_Network_Expansion/', net_filename,'.graphml'),
      name = net_synname,
      parentId=activity$properties$id ),
    used = syn_used,
    executed = this_file,
    activityName = act_name,
    activityDescription = act_desc
  )

}
```

```{r runcode}
################################################################################
# Assemble the List Object to Call all nets
all_goterms <- list(
  c('syn25185319', "APP_Metabolism", "APP Metabolism"),
  c('syn25185320', "Endolysosomal", "Endolysosomal"),
  c('syn25185321', "Epigenetic_Regulation", "Epigenetic Regulation"),
  c('syn25185322', "Immune_Response", "Immune Response"),
  c('syn25185323', "Lipid_Metabolism", "Lipid Metabolism"),
  c('syn25185324', "Mitochondria Metabolism", "Mitochondria Metabolism"),
  c('syn25185326', "Myelination", "Myelination"),
  c('syn25185327', "Oxidative_Stress", "Oxidative Stress"),
  c('syn25185329', "RNA_Spliceosome", "RNA Spliceosome"),
  c('syn25185328', "Regulation_of_Apoptosis", "Regulation of Apoptosis"),
  c('syn25185330', "Structural_Stabilization", "Structural Stabilization"),
  c('syn25185331', "Synaptic_Dysfunction", "Synaptic Dysfunction"),
  c('syn25185332', "Tau Homeostasis", "Tau Homeostasis"),
  c('syn25185333', "Vascular_Function", "Vascular Function")
)

# Assemble the List Object to Call all nets
leading_edge <- list(
  c('syn25185303', "APP_Metabolism", "APP Metabolism"),
  c('syn25185304', "Endolysosomal", "Endolysosomal"),
  c('syn25185305', "Epigenetic_Regulation", "Epigenetic Regulation"),
  c('syn25185306', "Immune_Response", "Immune Response"),
  c('syn25185307', "Lipid_Metabolism", "Lipid Metabolism"),
  c('syn25185308', "Mitochondria Metabolism", "Mitochondria Metabolism"),
  c('syn25185309', "Myelination", "Myelination"),
  c('syn25185310', "Oxidative_Stress", "Oxidative Stress"),
  c('syn25185312', "RNA_Spliceosome", "RNA Spliceosome"),
  c('syn25185311', "Regulation_of_Apoptosis", "Regulation of Apoptosis"),
  c('syn25185313', "Structural_Stabilization", "Structural Stabilization"),
  c('syn25185315', "Synaptic_Dysfunction", "Synaptic Dysfunction"),
  c('syn25185316', "Tau Homeostasis", "Tau Homeostasis"),
  c('syn25185317', "Vascular_Function", "Vascular Function")
)

all_biodomain <- list(
  c('syn25322503', "APP_Metabolism", "APP Metabolism"),
  c('syn25322504', "Endolysosomal", "Endolysosomal"),
  c('syn25322505', "Epigenetic_Regulation", "Epigenetic Regulation"),
  c('syn25322506', "Immune_Response", "Immune Response"),
  c('syn25322507', "Lipid_Metabolism", "Lipid Metabolism"),
  c('syn25322508', "Mitochondria_Metabolism", "Mitochondria Metabolism"),
  c('syn25322509', "Myelination", "Myelination"),
  c('syn25322511', "Oxidative_Stress", "Oxidative Stress"),
  c('syn25322514', "RNA_Spliceosome", "RNA Spliceosome"),
  c('syn25322513', "Regulation_of_Apoptosis", "Regulation of Apoptosis"),
  c('syn25322515', "Structural_Stabilization", "Structural Stabilization"),
  c('syn25322516', "Synaptic_Dysfunction", "Synaptic Dysfunction"),
  c('syn25322517', "Tau_Homeostasis", "Tau Homeostasis"),
  c('syn25322518', "Vascular_Function", "Vascular Function")
)

this_repo <- githubr::getRepo(repository = 'jgockley62/igraph_Network_Expansion', ref="branch", refName='master')
prov <- githubr::getPermlink(repository = this_repo, repositoryPath = 'code/03_PathTracing.Rmd')
      
################################################################################

##### All Go Terms
## - Run the whole list
time<-Sys.time()

allgo_gene <- list()
allgo_subnet <- list()
for (i in 1:length(all_goterms)) {
  ### Load Lists:
  genes <- list_load( all_goterms[[i]][1], net, is_syn = TRUE )
  sentinal <-  list_load( all_goterms[[i]][1], net, is_syn = TRUE )
  
  ### Run a Trace
  trace <- lapply(genes, short_paths, tnet=net, targets=genes, sentinals=sentinal)

  ### Filter the trace
  g_list <- trace_filter(trace)
  
  #store the genelists and subnets
  allgo_gene[[all_goterms[[i]][2]]] <- g_list
  allgo_subnet[[all_goterms[[i]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=all_goterms[[i]][2], net_synname=all_goterms[[i]][3],
    p_id = 'syn25190666', folder = 'All Go Terms',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Simple Wthin Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = all_goterms[[i]][1], 
    subset = g_list
  ) 
}

A <- Sys.time()-time

time<-Sys.time()

leading_genes <- list()
leading_subnest <- list()
##### Leading Edge
for (i in 1:length(leading_edge)){
  
  ### Load Lists:
  genes <- list_load( leading_edge[[i]][1], net, is_syn = TRUE )
  sentinal <-  list_load( leading_edge[[i]][1], net, is_syn = TRUE )
  
  ### Run a Trace
  trace <- lapply( genes, short_paths, tnet=net, targets=genes, sentinals=sentinal  )
  
  ### Filter the trace
  g_list <- trace_filter(trace)
  
  #Sink_of_List_method <- g_list
  #length(g_list)
  # 449
  
  
  #store the genelists and subnets
  leading_genes[[leading_edge[[i]][2]]] <- g_list
  leading_subnest[[leading_edge[[i]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=leading_edge[[i]][2], net_synname=leading_edge[[i]][3],
    p_id = 'syn25190666', folder = 'Leading Edge',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Simple Wthin Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = leading_edge[[i]][1], 
    subset = g_list
  ) 
}
B <- Sys.time()-time

###
##### All BioDomain Lists
## - Run the whole list
time<-Sys.time()

allbiodomain_gene <- list()
allbiodomain_subnet <- list()
for (i in 1:length(all_biodomain)) {
  ### Load Lists:
  genes <- list_load( all_biodomain[[i]][1], net, is_syn = TRUE )
  sentinal <-  list_load( all_biodomain[[i]][1], net, is_syn = TRUE )
  
  ### Run a Trace
  trace <- lapply(genes, short_paths, tnet=net, targets=genes, sentinals=sentinal)

  ### Filter the trace
  g_list <- trace_filter(trace)
  
  #store the genelists and subnets
  allbiodomain_gene[[all_biodomain[[i]][2]]] <- g_list
  allbiodomain_subnet[[all_biodomain[[i]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=all_biodomain[[i]][2], net_synname=all_biodomain[[i]][3],
    p_id = 'syn25190666', folder = 'All Biodomain',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Simple Wthin Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = all_biodomain[[i]][1], 
    subset = g_list
  ) 
}

C <- Sys.time()-time


```

```{r pairwise_run}

##### All Go Terms
## - Run the whole list
time<-Sys.time()

allgo_gene <- list()
allgo_subnet <- list()
all_genes <- NULL
for (sent in 1:length(all_goterms)){
  
  g_list <- NULL
  for (target in 1:length(all_goterms)){
    if (sent==target){
      
    }else{
      ### Load Lists:
      genes <- list_load( all_goterms[[target]][1], net, is_syn = TRUE )
      sentinal <-  list_load( all_goterms[[sent]][1], net, is_syn = TRUE )
      
      ### Run a Trace
      trace <- lapply(genes, short_paths, tnet=net, targets=genes, sentinals=sentinal)
    
      ### Filter the trace
      g_list <- c(g_list, trace_filter(trace))
    }
  }
  
  g_list <- g_list[!duplicated(g_list)]
  
  #store the genelists and subnets
  allgo_gene[[all_goterms[[sent]][2]]] <- g_list
  allgo_subnet[[all_goterms[[sent]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  all_genes <- c(all_genes, g_list)
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=all_goterms[[sent]][2], net_synname=all_goterms[[sent]][3],
    p_id = 'syn25190666', folder = 'All Go Term Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = all_goterms[[sent]][1], 
    subset = g_list
  ) 

}
A <- Sys.time()-time

## Push Leading Edge Combined to Synapse
store_net(
    network = net,
    net_filename='All_GoTerm_Combined_Network', net_synname='All Go Term Combined Network',
    p_id = 'syn25190666', folder = 'Megerded Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Combinded Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = do.call(rbind, all_goterms)[,1], 
    subset = all_genes[!duplicated(all_genes)]
  ) 
all_genes_wDups <- all_genes
all_genes_Uniq <- all_genes[!duplicated(all_genes)]

#Run Leading Edge Analysis
time<-Sys.time()

leading_genes <- list()
leading_subnest <- list()
alllead_genes <- NULL
for (sent in 1:length(leading_edge)){
  
  g_list <- NULL
  for (target in 1:length(leading_edge)){
    if (sent==target){
      
    }else{
      ### Load Lists:
      genes <- list_load( leading_edge[[target]][1], net, is_syn = TRUE )
      sentinal <-  list_load( leading_edge[[sent]][1], net, is_syn = TRUE )
      
      ### Run a Trace
      trace <- lapply(genes, short_paths, tnet=net, targets=genes, sentinals=sentinal)
    
      ### Filter the trace
      g_list <- c(g_list, trace_filter(trace))
    }
  }
  
  g_list <- g_list[!duplicated(g_list)]
  
  #store the genelists and subnets
  leading_genes[[leading_edge[[sent]][2]]] <- g_list
  leading_subnest[[leading_edge[[sent]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  alllead_genes <- c(alllead_genes, g_list)
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=leading_edge[[sent]][2], net_synname=leading_edge[[sent]][3],
    p_id = 'syn25190666', folder = 'Leading Term Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = leading_edge[[sent]][1], 
    subset = g_list
  ) 

}
B <- Sys.time()-time

## Push Leading Edge Combined to Synapse
store_net(
    network = net,
    net_filename='All_LeadingEdge_Combined_Network', net_synname='All Leading Edge Combined Network',
    p_id = 'syn25190666', folder = 'Megerded Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Combinded Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = do.call(rbind, leading_edge)[,1], 
    subset = alllead_genes[!duplicated(alllead_genes)]
  ) 
alllead_genes_wDups <- alllead_genes
alllead_genes_Uniq <- alllead_genes[!duplicated(alllead_genes)]


##### All BioDomain
#Run Biodomain Analysis
time<-Sys.time()

biodomain_genes <- list()
biodomain_subnest <- list()
allbiodomain_genes <- NULL
for (sent in 1:length(all_biodomain)){
  
  g_list <- NULL
  for (target in 1:length(all_biodomain)){
    if (sent==target){
      
    }else{
      ### Load Lists:
      genes <- list_load( all_biodomain[[target]][1], net, is_syn = TRUE )
      sentinal <-  list_load( all_biodomain[[sent]][1], net, is_syn = TRUE )
      
      ### Run a Trace
      trace <- lapply(genes, short_paths, tnet=net, targets=genes, sentinals=sentinal)
    
      ### Filter the trace
      g_list <- c(g_list, trace_filter(trace))
    }
  }
  
  g_list <- g_list[!duplicated(g_list)]
  
  #store the genelists and subnets
  biodomain_genes[[all_biodomain[[sent]][2]]] <- g_list
  biodomain_subnest[[all_biodomain[[sent]][2]]] <- induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% g_list]
  )
  
  allbiodomain_genes <- c(allbiodomain_genes, g_list)
  
  ### Store the Trace
  store_net(
    network = net,
    net_filename=all_biodomain[[sent]][2], net_synname=all_biodomain[[sent]][3],
    p_id = 'syn25190666', folder = 'Full Biodomain Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = all_biodomain[[sent]][1], 
    subset = g_list
  ) 

}
C <- Sys.time()-time

## Push Leading Edge Combined to Synapse
store_net(
    network = net,
    net_filename='All_Biodomain_Combined_Network', net_synname='All Biodomain Combined Network',
    p_id = 'syn25190666', folder = 'Megerded Pairwise Networks',
    act_name = 'Pathway Tracing Network', 
    act_desc = 'Combinded Pariwise Biodomain Tracing',
    code = NULL, 
    repo = NULL,
    prov_object = prov,
    syn_used = do.call(rbind, all_biodomain)[,1], 
    subset = allbiodomain_genes[!duplicated(allbiodomain_genes)]
  ) 
allbiodomain_genes_wDups <- allbiodomain_genes
allbiodomain_genes_Uniq <- allbiodomain_genes[!duplicated(allbiodomain_genes)]
```

```{r data_Explore}
par(mfrow=c(2,1))
hist(
  table(all_genes_wDups),
  las = 1,
  xlab = "Gene Occurance",
  main = "Frequency of All Go Term Genes in Merged Networks"
)
hist(
  table(alllead_genes_wDups), 
  las = 1,
  xlab="Gene Occurance",
  main = "Frequency of Leading Terms Genes in Merged Networks"
)

## 2607 Genes
total_genes <- c(alllead_genes_Uniq, all_genes_Uniq)
total_genes <- total_genes[!duplicated(total_genes)]

approach_a <- c( 
  names(
    table(alllead_genes)[table(alllead_genes)>1]
  ),
  names(
    table(all_genes_wDups)[table(all_genes_wDups)>1]
  )
)
approach_a <- names(table(approach_a)[table(approach_a)>1])
induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% approach_a]
)
# 2020 Genes
approach_b <- c( 
  names(
    table(alllead_genes)[table(alllead_genes)>5]
  ),
  names(
    table(all_genes_wDups)[table(all_genes_wDups)>5]
  )
)
approach_b <- approach_b[!duplicated(approach_b)]
induced_subgraph(
    net,
    v=V(net)[names(V(net)) %in% approach_b]
)

ggvenn::ggvenn(
  list(
    A = approach_a,
    B = approach_b
  ), 
  fill_color = c("#0073C2FF", "#EFC000FF"),
  stroke_size = 0.5, set_name_size = 4
)

ggvenn::ggvenn(
  list( 
    AllGoTerm = all_genes_Uniq,
    LeadingEdge = alllead_genes_Uniq
  ), 
  fill_color = c("#0073C2FF", "#EFC000FF"),
  stroke_size = 0.5, set_name_size = 4
)

###############################################################################
# Re-Load the  networks and calc meterics
#' this Function Loads a network object from synapse
#' 
#' @param syn_id the networks synID
#' @param form the format of the netwrok file eg. "graphml"
network_load <- function (syn_id, form) {
  import_net <- igraph::read_graph(
    file = syn_temp$get(syn_id)$path,
    format = form
  )
  return(import_net)
}

net_names <- c(
  "APP_Metabolism",	
  "Endolysosomal",	
  "Epigenetic_Regulation",	
  "Immune_Response",	
  "Lipid_Metabolism",	
  "Mitochondria_Metabolism",	
  "Myelination",
  "Oxidative_Stress",	
  "RNA_Spliceosome",	
  "Regulation_of_Apoptosis",	
  "Structural_Stabilization",	
  "Synaptic_Dysfunction",
  "Tau_Homeostasis",
  "Vascular_Function"
)

allgo_nets <- c(
  'syn25282251',
  'syn25282360',
  'syn25282459',
  'syn25282571',
  'syn25282680',
  'syn25282807',
  'syn25282931',
  'syn25283044',
  'syn25283144',
  'syn25283257',
  'syn25283382',
  'syn25283517',
  'syn25283654',
  'syn25283790'
)

names(allgo_nets) <- net_names

allgo_gene <- list()
allgo_subnet <- list()
all_genes <- NULL

for (pnet in names(allgo_nets)) {
  allgo_subnet[[pnet]] <- network_load(
    allgo_nets[[pnet]], 
    "graphml"
  )
  allgo_gene[[pnet]] <- names(igraph::V(allgo_subnet[[pnet]]))
  all_genes <- c(all_genes, allgo_gene[[pnet]]) 
}

all_genes_wDups <- all_genes
all_genes_Uniq <- all_genes[!duplicated(all_genes)]

### Leading Pull

alllead_nets <- c(
  'syn25285732',
  'syn25285773',
  'syn25285873',
  'syn25285938',
  'syn25285991',
  'syn25286043',
  'syn25286109',
  'syn25286893',
  'syn25288862',
  'syn25290320',
  'syn25290376',
  'syn25290421',
  'syn25290471',
  'syn25290519'
)
names(alllead_nets) <- net_names

leading_genes <- list()
leading_subnest <- list()
alllead_genes <- NULL


for (pnet in names(alllead_nets)) {
  leading_subnest[[pnet]] <- network_load(
    alllead_nets[[pnet]], 
    "graphml"
  )
  leading_genes[[pnet]] <- names(igraph::V(leading_subnest[[pnet]]))
  alllead_genes <- c(alllead_genes,  leading_genes[[pnet]]) 
}

alllead_genes_wDups <- alllead_genes
alllead_genes_Uniq <- alllead_genes[!duplicated(alllead_genes)]
###############################################################################
# Initial list :
listInput1 <- allgo_gene

names(listInput1)[13] <- 'Tau_Homeostasis'
names(listInput1)[6] <- "Mitochondria_Metabolism"

myList <- list()
foo_List <- list(
  listInput1[[1]],
  listInput1[[2]],
  listInput1[[3]],
  listInput1[[4]],
  listInput1[[5]],
  listInput1[[6]],
  listInput1[[7]],
  listInput1[[8]],
  listInput1[[9]],
  listInput1[[10]],
  listInput1[[11]],
  listInput1[[12]],
  listInput1[[13]],
  listInput1[[14]]
)
names(foo_List) <- names(listInput1)[1:14]

for(i in 1:length(names(foo_List))){
  temp <- apply( combn(names(foo_List), m=i), 2, as.list)
  for (p in 1:length(temp)){
    myList[[length(myList)+1]] <- temp[[p]]
  }
}
p1 = UpSetR::upset(
  UpSetR::fromList(foo_List), 
  order.by = "degree", 
  keep.order = TRUE, 
  empty.intersections = "on",
  intersections = myList
)

######## Leading genes
# Initial list :
listInput2 <- alllead_genes

names(listInput2)[13] <- 'Tau_Homeostasis'
names(listInput2)[6] <- "Mitochondria_Metabolism"

myList <- list()
foo_List <- list(
  listInput2[[1]],
  listInput2[[2]],
  listInput2[[3]],
  listInput2[[4]],
  listInput2[[5]],
  listInput2[[6]],
  listInput2[[7]],
  listInput2[[8]],
  listInput2[[9]],
  listInput2[[10]],
  listInput2[[11]],
  listInput2[[12]],
  listInput2[[13]],
  listInput2[[14]]
)
names(foo_List) <- names(listInput2)[1:14]

for(i in 1:length(names(foo_List))){
  temp <- apply( combn(names(foo_List), m=i), 2, as.list)
  for (p in 1:length(temp)){
    myList[[length(myList)+1]] <- temp[[p]]
  }
}
p2 = UpSetR::upset(
  UpSetR::fromList(foo_List), 
  order.by = "degree", 
  keep.order = TRUE, 
  empty.intersections = "on",
  intersections = myList
)




################################ Garbage
intersections = list(
  list("one"),
  list("two"),
  list("three"),
  list("four"),
  list("one", "two"),
  list("one", "three"),
  list("one", "four"),
  list("two", "four"),
  list("two", "three"),
  list("three", "four")
)

listInput1<-allgo_gene
p1 = UpSetR::upset(
  UpSetR::fromList(listInput1), 
  order.by = "degree", 
  keep.order = TRUE, 
  empty.intersections = "on",
  intersections = list(
  apply( combn(names(listInput1), m=1), 2, as.list),
  apply( combn(names(listInput1), m=2), 2, as.list),
  apply( combn(names(listInput1), m=3), 2, as.list),
  apply( combn(names(listInput1), m=4), 2, as.list),
  apply( combn(names(listInput1), m=5), 2, as.list),
  apply( combn(names(listInput1), m=6), 2, as.list),
  apply( combn(names(listInput1), m=7), 2, as.list),
  apply( combn(names(listInput1), m=8), 2, as.list),
  apply( combn(names(listInput1), m=9), 2, as.list),
  apply( combn(names(listInput1), m=10), 2, as.list),
  apply( combn(names(listInput1), m=11), 2, as.list),
  apply( combn(names(listInput1), m=12), 2, as.list),
  apply( combn(names(listInput1), m=13), 2, as.list),
  apply( combn(names(listInput1), m=14), 2, as.list)
  )
  )
p2 = upset(fromList(listInput2), 
           order.by = "degree", 
           keep.order = TRUE, 
           empty.intersections = "on",
           intersections = list(list("one", "two"), 
                                list("one"), 
                                list("two"), 
                                list("one", "three"), 
                                list("one", "four"), 
                                list("one", "two", "three"), 
                                list("one", "two", "four"), 
                                list("one", "two", "three", "four"), 
                                list("two", "three", "four"), 
                                list("one", "three", "four"), 
                                list("two", "three"), 
                                list("two", "four"), 
                                list("four"), 
                                list("three"), 
                                list("three", "four")
                                )
)
  
  








gene_rows <- c(
  names(table(all_genes)),
  names(table(alllead_genes))
)
gene_rows <- gene_rows[!duplicated(gene_rows)]

occurance <- as.data.frame(matrix(0, length(gene_rows), 2))
row.names(occurance) <- gene_rows
colnames(occurance) <- c("AllGoTerm", "LeadingEdge")

occurance[names(table(all_genes)),]$AllGoTerm <- as.numeric(table(all_genes))
occurance[names(table(alllead_genes)),]$LeadingEdge <- as.numeric(table(alllead_genes))

UpSetR::upset(
  as.matrix(occurance),
  sets = c('AllGoTerm','LeadingEdge'),
  sets.bar.color = "#56B4E9",
  order.by = "freq",
  empty.intersections = "on"
)


lt_input <- list( 
  AllGoTerm = as.character(table(all_genes)),
  LeadingEdge = as.character(table(alllead_genes))
)
us<-as.character(c(1:14))
ComplexHeatmap::list_to_matrix(lt=lt_input, universal_set = us)

lt_input <- list( 
  AllGoTerm = all_genes,
  LeadingEdge = alllead_genes
)
us = c(
  all_genes,
  alllead_genes
)
us <- us[!duplicated(us)]

ComplexHeatmap::list_to_matrix(lt=lt_input, universal_set = us)
universal_set = unique(unlist(lt))

foo = lapply(lt_input, function(x) intersect(x, us))

lt = list(a = sample(letters, 57, replace = T),
          b = sample(letters, 10),
          c = sample(letters, 57, replace = T))

universal_set <- letters
lt <- lt

if (!is.null(universal_set)) {
  lt = lapply(lt, function(x) intersect(x, universal_set))
}else {
  universal_set = unlist(lt)
}
mat = matrix(0, nrow = length(universal_set), ncol = length(lt))
rownames(mat) = sort(universal_set)
colnames(mat) = names(lt)
for (i in seq_along(lt)) {
  mat[as.character(unique(lt[[i]])), i] = mat[as.character(unique(lt[[i]])), i] + 1
}
   

ComplexHeatmap::list_to_matrix(lt)
ComplexHeatmap::list_to_matrix(lt, universal_set = letters)


UpSetR::upset( data=occurance )
```
